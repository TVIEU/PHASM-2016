************************************************************************************************************
*************************         		 PHASM-MI		         ***************************
****  POLARIZATION FROM HANLE EFFECT FOR STELLAR MAGNETISM - DISTRIBUTION MAPS AND INTEGRATED SIGNALS  *****

**********************          	    VIEU Thibault 2016		              **********************
**********************  Instituto de Astrofisica de Canarias / Université Paris-Sud   **********************
**********************               Contact : thibault.vieu@u-psud.fr                **********************
************************************************************************************************************

------------------------------------------------    INFOS    -----------------------------------------------

- PHASM-MI computes the liner polarization signals emitted from a stellar atmosphere in the presence of a global dipolar magnetic field. 
- You can get the asymmetric distributions of the Hanle resolved signals on the projected disk or the integrated signatures, which are non-zero because of the asymmetry introduced by the global field.
- The only free parameters in the .exe concern the geometry of the magnetic field (strength and inclination). If you want to change other parameters, you need to modify the c++ code, which is not hard since all the global physical constants are gathered at the very beginning.


-----------------------------------------  BEFORE RUNNING THE .EXE  ----------------------------------------

- Make sure that the file "rotation_axis.txt" is with the .exe
- Make sure that the four files containing the tables of the exponential integrals are in the folder "exp_int" which is in the same folder as the .exe


--------------------------------------------------  PLOT  --------------------------------------------------

- If you want automatic plots after the computation, put the right directory in the Python call at the very end of the c++ file. Otherwise, you will get an error.
- You can basically ignore this error (or don't get it if you enter '0') because the results have been computed correctly before. To plot them, copy the containt of "plot_python.txt" in a .py file and run it. This "plot_python.txt" file is automatically generated and is adapted with your request.
- You will find at the end of this README file a summary of all the possible codes.


---------------------------------------------  RECOMPILATION  ----------------------------------------------

- All the code is written in a single main.c++ file in order to make the recompilation easier.
- When recompiling the code, you may have troubles with static arrays, especially on Mac. Try dynamic ones.


---------------------------------------------  ANOTHER STAR  -----------------------------------------------

- We can quite easily modify the code to get the polarization signals from a different line or/and star.
- Make sure this line/star is suitable for our approximations.
- Modify the constants : ... in the first part of the c++ file.
- Modify the arrays in the function "hydro".


************************************************************************************************************

----------------------------------------  PYTHON CODES FOR THE PLOTS ---------------------------------------

------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------

IF YOU ASKED FOR THE 2D MAPS ('m') AND EVERY RESULT BUT 'd' :

#You need the following files generated by the c++ program : "res_alpha.txt", "res_ro.txt", "resultat.txt"

import numpy as np
import matplotlib.pyplot as plt
from numpy import *
from matplotlib.pyplot import *
res_alpha=loadtxt('res_alpha.txt')
res_ro=loadtxt('res_ro.txt')
data=loadtxt('resultat.txt')
alpha=res_alpha[:,0]
ro=res_ro[:,0]
r, theta = np.meshgrid(ro, alpha)
values = np.resize(data[:,2],(len(alpha),len(ro)))
fig, ax = plt.subplots(subplot_kw=dict(projection='polar'))
ax.set_theta_zero_location(\"S\")
ax.contourf(theta, r, values)
plt.show()

------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------

IF YOU ASKED FOR THE 2D MAPS ('m') AND 'd' :

#You need the following file generated by the c++ program : "resultat.txt"

import numpy as np
import matplotlib.pyplot as plt
from numpy import *
from matplotlib.pyplot import *
data=loadtxt('resultat.txt')
plt.semilogy()
plt.plot(data[:,1],data[:,2])
plt.show()

------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------

IF YOU ASKED FOR THE EVOLUTION OF THE INTEGRATED SIGNALS ('i') :

#You need the following file generated by the c++ program : "resultat.txt"

import numpy as np
import matplotlib.pyplot as plt
from numpy import *
from matplotlib.pyplot import *
data=loadtxt('resultat.txt')
plt.plot(data[:,0],data[:,1])
plt.show()

------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------